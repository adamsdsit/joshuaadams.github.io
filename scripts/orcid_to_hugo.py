#!/usr/bin/env python3
"""
Fetch public works from ORCID and generate:
- Hugo publication markdown files: content/publication/*.md
- BibTeX: data/publications.bib

Idempotent: removes only previously autogenerated files.
"""

from __future__ import annotations

import os
import re
import json
import urllib.request
from datetime import date
from pathlib import Path

ORCID_ID = os.getenv("ORCID_ID", "0000-0002-7185-9125").strip()
OUT_DIR = Path("content/publication")
BIB_DIR = Path("static")
BIB_PATH = BIB_DIR / "publications.bib"
AUTO_TAG = "autogen_orcid"
API_BASE = "https://pub.orcid.org/v3.0"


def slugify(s: str) -> str:
    s = s.lower().strip()
    s = re.sub(r"[^\w\s-]", "", s)
    s = re.sub(r"[\s_-]+", "-", s)
    return s.strip("-") or "publication"


def http_get_json(url: str) -> dict:
    req = urllib.request.Request(
        url,
        headers={
            "Accept": "application/json",
            "User-Agent": "orcid-to-hugo/2.0 (joshuaadams.dev)",
        },
    )
    with urllib.request.urlopen(req, timeout=30) as resp:
        data = resp.read().decode("utf-8")
    return json.loads(data)


def ensure_clean_outdir():
    OUT_DIR.mkdir(parents=True, exist_ok=True)
    for p in OUT_DIR.glob("*.md"):
        txt = p.read_text(encoding="utf-8", errors="ignore")
        if f"autogen: {AUTO_TAG}" in txt:
            p.unlink()


def safe_year(work_summary: dict) -> str:
    pub_date = work_summary.get("publication-date") or {}
    year = ((pub_date.get("year") or {}).get("value")) if isinstance(pub_date, dict) else None
    if year and re.fullmatch(r"\d{4}", str(year)):
        return str(year)
    return str(date.today().year)


def pick_title(work_summary: dict) -> str:
    title = (work_summary.get("title") or {}).get("title") or {}
    val = title.get("value") if isinstance(title, dict) else None
    return (val or "Untitled Work").strip()


def extract_external_ids(work_summary: dict) -> dict:
    out = {}
    ext = work_summary.get("external-ids") or {}
    ids = ext.get("external-id") if isinstance(ext, dict) else None
    if not ids:
        return out
    if isinstance(ids, dict):
        ids = [ids]
    for item in ids:
        t = (item.get("external-id-type") or "").lower()
        v = (item.get("external-id-value") or "").strip()
        if t and v and t not in out:
            out[t] = v
    ext_url = work_summary.get("url") or {}
    if isinstance(ext_url, dict) and ext_url.get("value"):
        out["url"] = ext_url["value"]
    return out


def format_doi_url(doi: str) -> str:
    doi = doi.strip()
    if doi.lower().startswith("http"):
        return doi
    return f"https://doi.org/{doi}"


def bib_escape(s: str) -> str:
    return s.replace("{", "\\{").replace("}", "\\}").replace("&", "\\&")


def main():
    ensure_clean_outdir()
    BIB_DIR.mkdir(parents=True, exist_ok=True)

    works = http_get_json(f"{API_BASE}/{ORCID_ID}/works")
    groups = works.get("group") or []

    bib_entries = []

    for g in groups:
        summaries = g.get("work-summary") or []
        if not summaries:
            continue
        ws = summaries[0]

        title = pick_title(ws)
        year = safe_year(ws)
        ext_ids = extract_external_ids(ws)

        doi = ext_ids.get("doi")
        doi_url = format_doi_url(doi) if doi else None
        url = ext_ids.get("url")

        wtype = (ws.get("type") or "").lower()
        pub_type = "article"
        if "conference" in wtype or "proceedings" in wtype:
            pub_type = "conference"
        elif "journal" in wtype:
            pub_type = "journal"
        elif "book" in wtype:
            pub_type = "book"

        slug = slugify(f"{year}-{title}")[:80]
        out_path = OUT_DIR / f"{slug}.md"

        front_matter = {
            "title": title,
            "date": f"{year}-01-01",
            "publication_types": [pub_type],
            "orcid": f"https://orcid.org/{ORCID_ID}",
            "autogen": AUTO_TAG,
            # optional: pdf path auto-link convention (see section 2)
            "pdf": f"/media/papers/{slug}.pdf",
        }

        md = ["---"]
        for k, v in front_matter.items():
            if isinstance(v, list):
                md.append(f"{k}: {json.dumps(v)}")
            else:
                md.append(f'{k}: "{v}"')
        md.append("---\n")

        md.append(f"**ORCID:** https://orcid.org/{ORCID_ID}\n")
        if doi_url:
            md.append(f"[DOI]({doi_url})\n")
        if url and (not doi_url or url != doi_url):
            md.append(f"[Link]({url})\n")

        # ScholarlyArticle JSON-LD
        jsonld = {
            "@context": "https://schema.org",
            "@type": "ScholarlyArticle",
            "name": title,
            "datePublished": year,
            "identifier": [f"https://orcid.org/{ORCID_ID}"],
        }
        if doi:
            jsonld["identifier"].append(f"DOI:{doi}")
            jsonld["sameAs"] = [doi_url] if doi_url else []
        if url:
            jsonld.setdefault("sameAs", [])
            if url not in jsonld["sameAs"]:
                jsonld["sameAs"].append(url)

        md.append("\n<script type=\"application/ld+json\">")
        md.append(json.dumps(jsonld, ensure_ascii=False))
        md.append("</script>\n")

        out_path.write_text("\n".join(md), encoding="utf-8")

        # Minimal BibTeX entry (no author list from ORCID public works summaries)
        key = slugify(f"adams{year}{title}")[:40]
        bib = [f"@misc{{{key},"]
        bib.append(f"  title = {{{bib_escape(title)}}},")
        bib.append(f"  year = {{{year}}},")
        bib.append(f"  note = {{ORCID: https://orcid.org/{ORCID_ID}}},")
        if doi:
            bib.append(f"  doi = {{{doi}}},")
        if url:
            bib.append(f"  url = {{{url}}},")
        bib.append("}\n")
        bib_entries.append("\n".join(bib))

    BIB_PATH.write_text("\n".join(bib_entries), encoding="utf-8")
    print(f"Generated Hugo publications + BibTeX from ORCID {ORCID_ID}")


if __name__ == "__main__":
    main()
